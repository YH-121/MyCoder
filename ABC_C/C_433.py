# アルゴリズム解説:
# 1. ランレングス圧縮 (Run-Length Encoding) を使用します。
#    文字列 S を「同じ数字が連続するブロック」に分解します。
#    例: S = "1122333" -> [(1, 2), (2, 2), (3, 3)]
#    ここで (数字, 個数) のペアとして管理します。
#
# 2. 隣り合うブロックを確認します。
#    「1122文字列」の定義より、ある数字 d が k 個続き、その直後に d+1 が k 個続く形になります。
#    ランレングス圧縮した結果の隣り合う2つのブロック (n1, c1), (n2, c2) について、
#    もし n2 == n1 + 1 であれば、そこから作れる「1122文字列」の個数は min(c1, c2) 個です。
#    （前半と後半で同じ長さ k を取る必要があり、k は両方の個数の少ない方に制限されるため）
#
# 3. 全ての隣接ブロックについて上記の条件を満たす場合の min(c1, c2) を足し合わせたものが答えです。
#    計算量はランレングス圧縮に O(|S|)、その後の走査もブロック数（最大 |S|）に比例するため、全体で O(|S|) となり十分高速です。

from itertools import groupby

S = input()
if not S:
    print(0)
    exit()

# ランレングス圧縮
# groupby を使って連続する文字をグループ化
groups = []
for k, g in groupby(S):
    groups.append((int(k), len(list(g))))

ans = 0
# 隣り合うグループを見ていく
for i in range(len(groups) - 1):
    val1, len1 = groups[i]
    val2, len2 = groups[i+1]

    # 条件: 後半の数字が前半の数字 + 1 であること
    if val2 == val1 + 1:
        # 作れるペアの数は、両方の個数のうち少ない方
        ans += min(len1, len2)

print(ans)